<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-02T16:03:43.713Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pytorch基础知识</title>
    <link href="http://example.com/2021/06/29/Pytorch%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/06/29/Pytorch%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-06-29T07:25:08.000Z</published>
    <updated>2021-07-02T16:03:43.713Z</updated>
    
    <content type="html"><![CDATA[<p>简介</p><p>之前一直都是用Tensorflow来做深度学习的（虽然也不怎么会用），现在发现好像Pytorch更主流一点，于是打算学习一下Pytorch的一些相关知识，虽然将来不太打算做算法，但是做毕设应该会用得到。</p><p>本文就简单介绍一些Pytorch里最基础的内容，以及一些最基本的机器学习模型的Pytorch实现。</p><span id="more"></span><h1 id="Pytorch基础知识"><a href="#Pytorch基础知识" class="headerlink" title="Pytorch基础知识"></a>Pytorch基础知识</h1><!-- toc --><ul><li><a href="#1-tensor">1. Tensor</a><ul><li><a href="#11-tensor---">1.1 Tensor的创建</a></li><li><a href="#12-tensor--">1.2 Tensor运算</a><ul><li><a href="#121-----">1.2.1 二元运算</a></li><li><a href="#122---">1.2.2 索引</a></li><li><a href="#123---">1.2.3 维度</a></li><li><a href="#124-------">1.2.4 线性代数操作</a></li><li><a href="#125-----">1.2.5 广播机制</a></li></ul></li><li><a href="#13-tensor-nparray---">1.3 Tensor和np.array的转化</a></li><li><a href="#14--tensor--gpu-">1.4 将Tensor放到GPU上</a></li></ul></li><li><a href="#2------">2. 梯度的计算</a><ul><li><a href="#21-----">2.1 基础知识</a></li><li><a href="#22--------">2.2 线性回归的实现</a></li></ul></li><li><a href="#3-torchnn">3. torch.nn</a><ul><li><a href="#31-module----">3.1 Module类的继承</a></li><li><a href="#32-sequential-modulelist-moduledict">3.2 Sequential，ModuleList和ModuleDict</a></li><li><a href="#33-----">3.3 模型参数</a></li><li><a href="#34------">3.4 模型的保存</a></li><li><a href="#35-gpu--">3.5 GPU计算</a></li></ul></li></ul><!-- tocstop --><h2 id="1-Tensor"><a href="#1-Tensor" class="headerlink" title="1. Tensor"></a>1. Tensor</h2><p>Pytorch的Tensor类其实与np.array有很多类似的地方。只不过它集成了梯度相关的各种接口，更适合在Pytorch中使用。</p><h3 id="1-1-Tensor的创建"><a href="#1-1-Tensor的创建" class="headerlink" title="1.1 Tensor的创建"></a>1.1 Tensor的创建</h3><p>有好多种创建Tensor的方法，比较基本的有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">torch.empty(*size)</span><br><span class="line">torch.rand(*size)</span><br><span class="line">torch.zeros(*size)</span><br><span class="line">torch.ones(*size)</span><br><span class="line">torch.Tensor([blabla])</span><br><span class="line">torch.linspace(start, end, cnt)</span><br><span class="line">torch.arange(start, end, step)</span><br><span class="line">torch.rand(*size)  <span class="comment"># 均匀分布</span></span><br><span class="line">torch.randn(*size)  <span class="comment"># 标准分布</span></span><br><span class="line">torch.normal(mean, std)  <span class="comment"># 正态分布</span></span><br><span class="line">torch.uniform(<span class="keyword">from</span>, to)  <span class="comment"># 均匀分布</span></span><br><span class="line">torch.randperm(n)  <span class="comment"># 0~(n-1)随机排列</span></span><br><span class="line">torch.Tensor.new_ones(*size)  <span class="comment"># 这个比较奇怪，是创建一个指定大小的与被调用的Tensor具有相同dtype和device的Tensor</span></span><br><span class="line">torch.randn_like(torch.Tensor)  <span class="comment"># 这个是创建一个与指定Tensor相同大小、类型的随机Tensor</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Tensor运算"><a href="#1-2-Tensor运算" class="headerlink" title="1.2 Tensor运算"></a>1.2 Tensor运算</h3><h4 id="1-2-1-二元运算"><a href="#1-2-1-二元运算" class="headerlink" title="1.2.1 二元运算"></a>1.2.1 二元运算</h4><p>以加法为例，有三种形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.add(x, y)</span><br><span class="line">x + y</span><br><span class="line">x.add_(y)   <span class="comment"># 就地操作</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-索引"><a href="#1-2-2-索引" class="headerlink" title="1.2.2 索引"></a>1.2.2 索引</h4><p>至于索引操作，要注意索引出来的内容实际上仍然是原Tensor中的内容，并不是一份复制。所以要防止误修改导致的不好的后果。</p><p>此外有一个特殊的函数item()，用于将只有一个元素的Tensor转换成相应的数字。</p><h4 id="1-2-3-维度"><a href="#1-2-3-维度" class="headerlink" title="1.2.3 维度"></a>1.2.3 维度</h4><p>Tensor提供了view(*size)函数，有点类似于数据库里view的概念，可以将Tensor转化成指定维度组合的形式，但实际的数据与变换之前的Tensor是共用的。</p><h4 id="1-2-4-线性代数操作"><a href="#1-2-4-线性代数操作" class="headerlink" title="1.2.4 线性代数操作"></a>1.2.4 线性代数操作</h4><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>trace</td><td>对角线元素之和(矩阵的迹)</td></tr><tr><td>diag</td><td>对角线元素</td></tr><tr><td>triu/tril</td><td>矩阵的上三角/下三角，可指定偏移量</td></tr><tr><td>mm/bmm</td><td>矩阵乘法，batch的矩阵乘法</td></tr><tr><td>addmm/addbmm/addmv/addr/baddbmm..</td><td>矩阵运算</td></tr><tr><td>t</td><td>转置</td></tr><tr><td>dot/cross</td><td>内积/外积</td></tr><tr><td>inverse</td><td>求逆矩阵</td></tr><tr><td>svd</td><td>奇异值分解</td></tr></tbody></table></div><h4 id="1-2-5-广播机制"><a href="#1-2-5-广播机制" class="headerlink" title="1.2.5 广播机制"></a>1.2.5 广播机制</h4><p>当大小不同的Tensor进行运算时，会发生一定的广播行为。比如，2*1的矩阵与1*3的矩阵相加，第一个矩阵会被复制两列，而第二个矩阵会被复制一行，变成两个2*3的矩阵，然后相加。</p><h3 id="1-3-Tensor和np-array的转化"><a href="#1-3-Tensor和np-array的转化" class="headerlink" title="1.3 Tensor和np.array的转化"></a>1.3 Tensor和np.array的转化</h3><p>有三个常见的函数用于处理两者转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = t.numpy()   <span class="comment"># 不拷贝</span></span><br><span class="line">t = torch.from_numpy(a)   <span class="comment"># 不拷贝</span></span><br><span class="line">t = torch.tensor(a)   <span class="comment"># 拷贝</span></span><br></pre></td></tr></table></figure><h3 id="1-4-将Tensor放到GPU上"><a href="#1-4-将Tensor放到GPU上" class="headerlink" title="1.4 将Tensor放到GPU上"></a>1.4 将Tensor放到GPU上</h3><p>对于已经创建的Tensor，可以使用to()函数将其设为GPU Tensor；或者可以在创建时添加device参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    cuda_device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    x = x.to(cuda_device)  <span class="comment"># 等价于x = x.to(&quot;cuda&quot;)</span></span><br><span class="line">    y = torch.ones_like(x, device=cuda_device)</span><br></pre></td></tr></table></figure><h2 id="2-梯度的计算"><a href="#2-梯度的计算" class="headerlink" title="2. 梯度的计算"></a>2. 梯度的计算</h2><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><p>假如对于一个张量x，接下来想要对它构造函数并且求梯度，那么我们需要将x的requires<em>grad属性设为True。可以在创建的时候指定参数，也可以使用requires_grad</em>(bool)函数。</p><p>接下来，所有使用到x构造的张量（比如<code>y=x+1</code>）都会自动将这个属性置为True，并形成一个函数图。</p><p>组装完成后，对其中某一个张量（通常当然是最后一个了）调用backward()函数，就会生成梯度信息。比如调用了z.backward()，那么x.grad()就表示z对x的梯度。（注意这里x必须是叶子结点）</p><p>值得注意的是，这个梯度值是累加上去的，而不是把之前的grad清掉重新写，所以如果需要清掉，需要通过<code>x.grad.data.zero_()</code>手动清掉。</p><p>此外，在调用backward()的时候，如果目标函数不是一个标量函数，需要给出一个与目标函数同型的张量作为参数，这个张量表示每个位置的权重，从而线性合并成一个标量函数。</p><p>还有一点，如果我们想修改一个requires_grad的张量，又不希望记录这次梯度，可以直接对tensor.data进行操作。</p><h3 id="2-2-线性回归的实现"><a href="#2-2-线性回归的实现" class="headerlink" title="2.2 线性回归的实现"></a>2.2 线性回归的实现</h3><p>为了更加熟悉Tensor和梯度的操作，我们不依赖Tensor之外的Pytorch组件来实现一个简单的线性回归。</p><p>首先我们构造数据集。我们构造一个二元线性函数，并添加一个高斯噪声：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M = <span class="number">2</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line">w_t = [<span class="number">2</span>, -<span class="number">3.4</span>]</span><br><span class="line">b_t = [<span class="number">4.2</span>]</span><br><span class="line">X = torch.randn(N, M, dtype=torch.float32)</span><br><span class="line">y = w_t[<span class="number">0</span>] * X[:, <span class="number">0</span>] + w_t[<span class="number">1</span>] * X[:, <span class="number">1</span>] + b_t[<span class="number">0</span>] + torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=N), dtype=torch.float32)</span><br></pre></td></tr></table></figure><p>接下来定义数据集的batch生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter</span>(<span class="params">batch_size, X, y</span>):</span></span><br><span class="line">    N = <span class="built_in">len</span>(X)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(N))</span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N, batch_size):</span><br><span class="line">        j = torch.LongTensor(indices[i: <span class="built_in">min</span>(i + batch_size, N)])</span><br><span class="line">        <span class="keyword">yield</span> X.index_select(<span class="number">0</span>, j), y.index_select(<span class="number">0</span>, j)</span><br></pre></td></tr></table></figure><p>在python中，像上面这样带有yield关键字的函数就不再是普通的函数类型，而是生成器类型。具体机制感觉不是很好懂，但是这里也就是用一下，不太想仔细研究这个。反正上面定义的这个生成器的使用方法就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X_batch, y_batch <span class="keyword">in</span> data_iter(<span class="number">10</span>, X, y):</span><br><span class="line">    blabla</span><br></pre></td></tr></table></figure><p>接下来构建模型。要构造一个模型，主要需要定义清楚模型本身的正向计算公式、损失函数、优化器，并给定batch-size和learning-rate等超参数。同时还要对模型参数进行初始化。</p><p>那么，我们实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">w = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (M, <span class="number">1</span>)), dtype=torch.float32, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, dtype=torch.float32, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linreg</span>(<span class="params">X, w, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.mm(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_loss</span>(<span class="params">y_hat, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.view(y_hat.size())) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.data -= lr * param.grad / batch_size</span><br><span class="line">        </span><br><span class="line">lr = <span class="number">0.015</span></span><br><span class="line">N_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(N_epochs):</span><br><span class="line">    <span class="keyword">for</span> X_batch, y_batch <span class="keyword">in</span> data_iter(batch_size, X, y):</span><br><span class="line">        l = loss(net(X, w, b), y).<span class="built_in">sum</span>()</span><br><span class="line">        l.backward()</span><br><span class="line">        sgd([w,b], lr, batch_size)</span><br><span class="line">        </span><br><span class="line">        w.grad.data.zero_()</span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    train_l = loss(net(X, w, b), y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %f&#x27;</span> % (epoch + <span class="number">1</span>, train_l.mean().item()))</span><br></pre></td></tr></table></figure><h2 id="3-torch-nn"><a href="#3-torch-nn" class="headerlink" title="3. torch.nn"></a>3. torch.nn</h2><p>说归说，做归做。介绍了半天怎么用基本的功能来搭建模型，我们总不能真的用这些东西搭复杂的神经网络出来。因此，前面搭的这个线性回归模型，只是熟悉一下pytorch中Tensor的一些基本的接口，而接下来要介绍的，才是搭模型的时候真正要用的东西。</p><h3 id="3-1-Module类的继承"><a href="#3-1-Module类的继承" class="headerlink" title="3.1 Module类的继承"></a>3.1 Module类的继承</h3><p>要搭建一个神经网络模型，其中一种很常用的方法就是继承torch.nn.Module类（注意是Module不是Model）。</p><p>以下就是一个很简单的多层感知器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__(**kwargs)</span><br><span class="line">        self.hidden = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        self.act = nn.ReLU()</span><br><span class="line">        self.output = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        a = self.act(self.hidden(x))</span><br><span class="line">        <span class="keyword">return</span> self.output(a)</span><br></pre></td></tr></table></figure><p>此外，这样的设计使得Module之间是可以嵌套和组合的。nn.Linear就是一个Module，因而它可以直接作为一个模型进行训练，也可以放入其他Module中作为一个模块。</p><h3 id="3-2-Sequential，ModuleList和ModuleDict"><a href="#3-2-Sequential，ModuleList和ModuleDict" class="headerlink" title="3.2 Sequential，ModuleList和ModuleDict"></a>3.2 Sequential，ModuleList和ModuleDict</h3><p>在Pytorch中有三个常用的Module的派生类，分别是Sequential，ModuleList和ModuleDict。</p><p>Sequential是定义好了forward()函数的，也就是说，我们只要直接创建一个Sequential对象就可以对它进行训练和预测，而ModuleList和ModuleDict是没有的。这也就要求在构造Sequential的时候前后的层之间的维度要对齐。</p><p>ModuleList和ModuleDict提供了和list, dict类似的接口，在此之外，它们是可以直接获取到每一层的参数信息的。</p><h3 id="3-3-模型参数"><a href="#3-3-模型参数" class="headerlink" title="3.3 模型参数"></a>3.3 模型参数</h3><p>Module提供了两个访问参数的生成器：parameters()和named_parameters()。分别用于遍历参数和名字+参数。</p><p>Parameter类派生自Tensor类，基本操作是相同的，但Module中的Parameter会自动被添加到模型参数中，而Tensor不会。</p><p>至于模型参数的初始化，torch.nn.init里提供了一些基本的初始化函数，如<code>normal_(tensor)</code>函数，将tensor中的数据就地以正态分布初始化。此外还有<code>constant_(tensor)</code>函数。我们也可以自定义。自定义时，可以参考<code>normal_()</code>的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal_</span>(<span class="params">tensor, mean=<span class="number">0</span>, std=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">return</span> tensor.normal_(mean, std)</span><br></pre></td></tr></table></figure><h3 id="3-4-模型的保存"><a href="#3-4-模型的保存" class="headerlink" title="3.4 模型的保存"></a>3.4 模型的保存</h3><p>保存模型，可以使用Tensor的save和load方法，他们内部调用了pickle库进行序列化和反序列化。也可以使用torch.save来保存模型的state_dict，并用load_state_dict进行加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br><span class="line"></span><br><span class="line">model = XXXModel()</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br></pre></td></tr></table></figure><p>此外，还可以直接保存和读取模型本身：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model, PATH)</span><br><span class="line"></span><br><span class="line">model = torch.load(PATH)</span><br></pre></td></tr></table></figure><h3 id="3-5-GPU计算"><a href="#3-5-GPU计算" class="headerlink" title="3.5 GPU计算"></a>3.5 GPU计算</h3><p>我们可以通过tensor.cuda(idx=0)将tensor放置在GPU上（不是就地的），也可以通过model.cuda(idx=0)将模型放置在GPU上。要注意，模型输入的Tensor必须和模型位于同一设备上，才能进行计算。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;之前一直都是用Tensorflow来做深度学习的（虽然也不怎么会用），现在发现好像Pytorch更主流一点，于是打算学习一下Pytorch的一些相关知识，虽然将来不太打算做算法，但是做毕设应该会用得到。&lt;/p&gt;
&lt;p&gt;本文就简单介绍一些Pytorch里最基础的内容，以及一些最基本的机器学习模型的Pytorch实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.828-Lab1</title>
    <link href="http://example.com/2021/06/21/MIT6-828-Lab1/"/>
    <id>http://example.com/2021/06/21/MIT6-828-Lab1/</id>
    <published>2021-06-21T13:50:06.000Z</published>
    <updated>2021-06-28T16:16:35.001Z</updated>
    
    <content type="html"><![CDATA[<p>今天决定开始刷MIT6.828的实验。算是弥补一下鄙校操作系统课程实验非常落后而愚蠢的缺憾吧。这篇笔记的内容呢，主要是我在实验过程中的一些主要思路和关键点的记录，所以可能并不能作为一篇详尽的实验指导性质的文字，因为很多操作上的、工具使用上的小细节我是没有一一列出的。假如你是自己独立地在钻研这个实验，对工具有一定的熟悉程度，经过重复的研究和思考之后，卡在某些地方，在本文中找到一些小的启发倒是有可能的。当然，很多内容也是我结合曾经课上课下所学的各种知识所做的一些个人分析，错误也是肯定会有的。好了，话不多说，直接开始。</p><span id="more"></span><h1 id="MIT6-828-Lab1-Booting-a-PC"><a href="#MIT6-828-Lab1-Booting-a-PC" class="headerlink" title="MIT6.828 Lab1 Booting a PC"></a>MIT6.828 Lab1 Booting a PC</h1><!-- toc --><ul><li><a href="#----">环境搭建</a></li><li><a href="#part-1--pc-bootstrap">Part 1: PC Bootstrap</a><ul><li><a href="#exercise-1-----x86--">Exercise 1 - 熟悉x86汇编</a></li><li><a href="#exercise-2-----bios">Exercise 2 - 了解BIOS</a><ul><li><a href="#------">物理地址空间</a></li><li><a href="#bios">BIOS</a></li></ul></li></ul></li><li><a href="#part-2--the-boot-loader">Part 2: The Boot Loader</a><ul><li><a href="#exercise-3-----boot-loader">Exercise 3 - 熟悉Boot Loader</a><ul><li><a href="#-----------">实模式到保护模式的切换</a></li><li><a href="#bootmain-----">bootmain函数的执行</a></li></ul></li><li><a href="#exercise-4-----c---">Exercise 4 - 熟悉C和指针</a></li><li><a href="#exercise-5-----elf">Exercise 5 - 熟悉ELF</a></li><li><a href="#exercise-6--------">Exercise 6 - 内核的装载</a></li></ul></li><li><a href="#part-3--the-kernel">Part 3: The Kernel</a><ul><li><a href="#exercise-7----------">Exercise 7 - 虚拟内存的开启</a></li><li><a href="#exercise-8---print">Exercise 8 - print</a></li><li><a href="#exercise-9--------">Exercise 9 - 栈的初始化</a></li><li><a href="#exercise-10---------">Exercise 10 - 函数调用与栈</a></li><li><a href="#exercise-11-----backtrace">Exercise 11 - 实现backtrace</a></li><li><a href="#exercise-12--------">Exercise 12 - 搜索符号表</a></li></ul></li><li><a href="#--">小结</a></li></ul><!-- tocstop --><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>MIT提供了一个服务器，上面有实验需要的模拟器环境，但是我们似乎进不去…于是只能在自己的电脑上搭了。</p><p>搭建的过程这里完全参考了这个链接中的办法。完全照着做下来就可以搭好：<a href="https://github.com/woai3c/MIT6.828/blob/master/docs/install.md">https://github.com/woai3c/MIT6.828/blob/master/docs/install.md</a></p><p>顺便记录一下这里使用的环境。在Windows上搭当然是不太现实啦，刚开始尝试用WSL但是也失败了（肯定不是WSL有问题..WSL肯定也是能配好的嗷但是我不想折腾了），于是换用VMware Workstation 16 + Ubuntu18.04，x86-64架构，内核版本是5.4.0。</p><h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="Exercise-1-熟悉x86汇编"><a href="#Exercise-1-熟悉x86汇编" class="headerlink" title="Exercise 1 - 熟悉x86汇编"></a>Exercise 1 - 熟悉x86汇编</h3><p>练习1的内容是熟悉一下x86的汇编，我们就跳过啦。刚写完自己的编译器，已经挺熟悉了…</p><p>注意x86的汇编有AT&amp;T和Intel两种格式，本质上是完全等效的，只是一些语法细节（比如源操作数和目的操作数的顺序等）略有不同。具体用哪一种当然是取决于汇编器咯，gcc的as工具的话用的是AT&amp;T格式，而NASM工具则是使用Intel格式。所以接下来我们主要要用到的也就是AT&amp;T格式的x86汇编。</p><h3 id="Exercise-2-了解BIOS"><a href="#Exercise-2-了解BIOS" class="headerlink" title="Exercise 2 - 了解BIOS"></a>Exercise 2 - 了解BIOS</h3><h4 id="物理地址空间"><a href="#物理地址空间" class="headerlink" title="物理地址空间"></a>物理地址空间</h4><p>32位机支持4GB的寻址空间。在这4GB的物理地址中，最低的1MB是比较特殊的，其中0~640KB被称为低地址，640KB~768KB预留给VGA显示缓冲，768KB~960KB留给16位的设备，960KB~1M则作为BIOS ROM使用。</p><p>这是为什么呢，是因为在早期的8086处理器架构下，最多只支持1MB的物理内存。上述的低地址，也就是这种架构下计算机实际使用的内存区域（还敢不敢开大数组了）。后来尽管内存空间迅速扩大，但为了保持对早期架构的兼容性，最低的1MB内存保留了最初的结构，新的特性则在1MB之后的空间上做扩展。反正单位都变成GB了，也不差这1MB了..</p><h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>BIOS（基本输入输出系统）是一段固化在主板ROM上的代码。机器启动时，会被自动装载进相应的内存地址中，并由CPU执行。</p><p>练习2要求我们使用gdb跟踪BIOS，简单地研究一下BIOS在做的事情。</p><p>首先在两个终端下分别运行以下两条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make qemu-gdb</span><br><span class="line">make gdb</span><br></pre></td></tr></table></figure><p>然后gdb就自动中断在了<code>.gdbinit</code>文件中事先指定好的位置。这里是启动早期的一条指令的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure><p>接下来做了一些暂时看不出目的的操作之后，有这样几行指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[f000:d15f]    0xfd15f:cli    </span><br><span class="line">[f000:d160]    0xfd160:cld    </span><br><span class="line">[f000:d161]    0xfd161:mov    $0x8f,%eax</span><br><span class="line">[f000:d167]    0xfd167:out    %al,$0x70</span><br><span class="line">[f000:d169]    0xfd169:in     $0x71,%al</span><br></pre></td></tr></table></figure><p>cli指令即clear interruption，将中断标志位置0，也就是不允许中断。这里的中断，指的是可屏蔽中断。而接下来的out %al, $0x70，则是用来禁止不可屏蔽中断（NMI）。这条指令是什么意思呢？</p><p>in和out这一对指令，是用于操作端口映射的设备（与内存映射设备相对应）。每个端口映射设备对应一个端口号，与内存地址是两套不同的排布，因此访问端口映射设备自然也不能使用与访问内存相同的指令。in和out的作用就是从某个端口取数据，或者将数据写入到某个端口。</p><p>而0x70端口的最高位，就是控制NMI是否允许发生的信号。</p><p>简单来说，在BIOS的初期，首先关闭了各种中断操作，确保BIOS程序可以在不受干扰的情况下顺利完成。</p><p>接下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[f000:d16b]    0xfd16b:in     $0x92,%al</span><br><span class="line">[f000:d16d]    0xfd16d:or     $0x2,%al</span><br><span class="line">[f000:d16f]    0xfd16f:out    %al,$0x92</span><br></pre></td></tr></table></figure><p>将0x92号端口的数据的倒数第二位设置为1. 那么0x92号端口的倒数第二位是什么呢？查阅资料可知，它代表A20线的开关。A20线又是个啥？这就与刚刚提到的内存的演进有关了。当A20线关闭时，表示只支持1M的内存。反之，则允许20位之前的地址线的使用。所以，这里的操作就是开启了A20线。这是为接下来开启保护模式做准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[f000:d171]    0xfd171:lidtw  %cs:0x6ab8</span><br><span class="line">[f000:d177]    0xfd177:lgdtw  %cs:0x6a74</span><br><span class="line">[f000:d17d]    0xfd17d:mov    %cr0,%eax</span><br><span class="line">[f000:d180]    0xfd180:or     $0x1,%eax</span><br><span class="line">[f000:d184]    0xfd184:mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>接下来就是加载了idt和gdt，也就是中断描述符表和全局描述符表。</p><p>至于全局描述符表是啥，简单来说就是一个用于实现保护模式的数据结构。它用来标识内存中不同段的属性。</p><p>然后将%cr0寄存器的最低位置1，也就是开启保护模式。接着，聪明的gdb就提示我们说：The target architecture is assumed to be i386，验证了我们的分析。</p><p>不过，我猜测，这里应该只是一个简单的测试行为，后面还会回到实模式继续执行其他指令。</p><p>接下来的代码，就变得扑朔迷离了。首先是将所有段寄存器置成了0x10，然后开始进行函数调用，一层一层调进去，全都是一些数据移动操作，很难看出实际在完成的任务了。那么这个练习就到这里为止吧~</p><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><h3 id="Exercise-3-熟悉Boot-Loader"><a href="#Exercise-3-熟悉Boot-Loader" class="headerlink" title="Exercise 3 - 熟悉Boot Loader"></a>Exercise 3 - 熟悉Boot Loader</h3><p>计算机要进一步启动，需要一个启动设备。BIOS会搜索每一个硬盘、软盘等设备，检查它们是否是一个启动盘。如何表明自己是一个启动盘呢？就是在盘的第一个扇区上保存一段特殊的代码，称为boot loader。这个扇区则称为启动扇区。一旦BIOS发现了启动扇区，就会将该扇区的boot loader装载到0x7c00~0x7dff的内存空间中，并跳转到0x7c00开始执行boot loader代码。</p><p>Boot loader代码有两项主要任务：</p><ul><li>将处理器切换到保护模式</li><li>装载内核</li></ul><p>我们接下来的任务，就是阅读6.828预先提供的Boot Loader的代码，理解其行为。代码位于<code>boot/boot.S</code>和<code>boot/main.c</code>中。</p><p>真正的入口是<code>boot.S</code>。它为<code>main.c</code>的执行做准备。而<code>main.c</code>则执行了具体的装载内核的工作。简单浏览之后，我们开始进行跟踪的工作。</p><h4 id="实模式到保护模式的切换"><a href="#实模式到保护模式的切换" class="headerlink" title="实模式到保护模式的切换"></a>实模式到保护模式的切换</h4><p>我们在0x7c00处设置断点，并执行到该断点。</p><p>展示一下断点下方将要执行的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i 0x00007c00</span><br><span class="line">=&gt; 0x7c00:cli    </span><br><span class="line">   0x7c01:cld    </span><br><span class="line">   0x7c02:xor    %ax,%ax</span><br><span class="line">   0x7c04:mov    %ax,%ds</span><br><span class="line">   0x7c06:mov    %ax,%es</span><br><span class="line">   0x7c08:mov    %ax,%ss</span><br><span class="line">   0x7c0a:in     $0x64,%al</span><br><span class="line">   0x7c0c:test   $0x2,%al</span><br><span class="line">   0x7c0e:jne    0x7c0a</span><br><span class="line">   0x7c10:mov    $0xd1,%al</span><br></pre></td></tr></table></figure><p>这对应的正是<code>boot.S</code>中start标签下的代码。可以看到，我们已经顺利来到了boot loader的执行。</p><p>跳过若干代码，直到 [0: 7c1e] 处的 lgdtw 0x7c64，准备要开始进入保护模式了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7c1e:lgdtw  0x7c64</span><br><span class="line">0x7c23:mov    %cr0,%eax</span><br><span class="line">0x7c26:or     $0x1,%eax</span><br><span class="line">0x7c2a:mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>这里首先加载全局描述符表，然后将%cr0[0]置位。下一条指令则完成了实模式到保护模式的切换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c2d] =&gt; 0x7c2d:ljmp   $0x8,$0x7c32</span><br></pre></td></tr></table></figure><p>对应于<code>boot.S</code>中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>也就是跳转到了真正的保护模式32位代码段，进而创建堆栈，跳转到bootmain函数。栈底位于0x7c00，也就是boot loader的上方。</p><h4 id="bootmain函数的执行"><a href="#bootmain函数的执行" class="headerlink" title="bootmain函数的执行"></a>bootmain函数的执行</h4><p>bootmain函数的逻辑非常清楚，首先从磁盘上读取8个扇区（也就是4KB）大小的内容。注意，这里的8个扇区是从启动扇区的后一个扇区开始的，因为readseg中的这一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>保证了最小的offset为1（offset指以扇区数为单位的偏移量）。</p><p>接下来是一个简单的检查，检查读取到的内容是否是ELF（可执行可链接）格式。如果不是则进入错误处理环节。</p><p>下面是一个循环。循环的目的是根据ELF头和程序头的指示从磁盘中读取各个程序段。在循环之前，初始化了两个变量ph和eph，分别为ProgramHeader和EndofProgramHeader之意。其指向是通过ELF头中的信息获取的。接着，对每一个程序头，读出其程序段在文件中的位置和大小，并将对应的程序段加载到内存中相应地址。</p><p>完成之后，则通过ELF头中的入口地址信息跳转到相应位置开始执行。</p><p>这样一来我们就可以回答练习中的问题了。</p><blockquote><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p></blockquote><p>Boot loader执行的最后一条指令也就是调用ELFHDR-&gt;e_entry的指令，位于0x00007d6b处，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *0x10018</span><br></pre></td></tr></table></figure><p>而内核执行的第一条指令也就是上述call指令跳转到的指令，即0x10018处存放的地址。在上述call指令处设置断点，并向下执行，可以看到程序跳转到了0x10000c，指令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw $0x1234, 0x472</span><br></pre></td></tr></table></figure><blockquote><p><em>Where</em> is the first instruction of the kernel?</p></blockquote><p>执行的第一条指令的内存地址，刚刚已经分析过了，即0x10018处保存的四个字节的地址值，0x10000c。为了进一步明确整个加载的过程，使用x/Nx命令将0x10000（即ELF头的起始位置）开始的若干个内存打印出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x10000:0x464c457f0x000101010x000000000x00000000</span><br><span class="line">0x10010:0x000300020x000000010x0010000c0x00000034</span><br><span class="line">0x10020:0x000152f80x000000000x002000340x00280003</span><br><span class="line">0x10030:0x000e000f0x000000010x000010000xf0100000</span><br><span class="line">0x10040:0x001000000x0000759d0x0000759d0x00000005</span><br><span class="line">0x10050:0x000010000x000000010x000090000xf0108000</span><br><span class="line">0x10060:0x001080000x0000b6a80x0000b6a80x00000006</span><br><span class="line">0x10070:0x000010000x6474e5510x000000000x00000000</span><br><span class="line">0x10080:0x000000000x000000000x000000000x00000007</span><br><span class="line">0x10090:0x000000100x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>结合ELF头和程序段头的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> e_magic;</span><br><span class="line"><span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">uint16_t</span> e_type;</span><br><span class="line"><span class="keyword">uint16_t</span> e_machine;</span><br><span class="line"><span class="keyword">uint32_t</span> e_version;</span><br><span class="line"><span class="keyword">uint32_t</span> e_entry;</span><br><span class="line"><span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line"><span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line"><span class="keyword">uint32_t</span> e_flags;</span><br><span class="line"><span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line"><span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line"><span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line"><span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line"><span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line"><span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> p_type;</span><br><span class="line"><span class="keyword">uint32_t</span> p_offset;</span><br><span class="line"><span class="keyword">uint32_t</span> p_va;</span><br><span class="line"><span class="keyword">uint32_t</span> p_pa;</span><br><span class="line"><span class="keyword">uint32_t</span> p_filesz;</span><br><span class="line"><span class="keyword">uint32_t</span> p_memsz;</span><br><span class="line"><span class="keyword">uint32_t</span> p_flags;</span><br><span class="line"><span class="keyword">uint32_t</span> p_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过简单的计数可以发现，第二行的最后一个word保存的是e_phoff字段，指示程序段头的偏移量为0x00000034，也就是说0x00010034处开始为Proghdr的内容。那么e_phnum字段在哪里呢，数一数发现应该位于0x0001002c处的两个字节。要注意的是，x86架构采用小端规则，因此在上面的内存中展示出来的0x00280003，实际上在内存中的顺序是03 00 00 28。因而e_phnum的值实际上是03 00对应的16位整数值，即3.</p><p>接下来就是proghdr了。从0x00010034开始，每32个字节即为一个程序段的头部。在第一个头部中，很容易读出p_offset=0x00001000，p_pa=0x0010000，p_memsz=0x0000759d。也就是说，第一个程序段位于ELF的0x1000处，大小为0x759d，将要被加载到的内存地址是0x100000。那么，e_entry所指的0x10000c，即为该程序段偏移0x10000c-0x100000=0xc字节的位置，也就是说，内核执行的第一条指令位于ELF中的0x100c位置。</p><blockquote><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p></blockquote><p>事实上刚刚的分析已经回答了这个问题。boot loader会根据elfhdr和proghdr的指示，装载相应的扇区进入内存。</p><h3 id="Exercise-4-熟悉C和指针"><a href="#Exercise-4-熟悉C和指针" class="headerlink" title="Exercise 4 - 熟悉C和指针"></a>Exercise 4 - 熟悉C和指针</h3><p>接下来的练习4中，让我们阅读一些C和指针相关的资料，并且再三强调除非你对C和指针特别熟悉，否则一定不要跳过这一步骤，不然可能会有灭顶之灾。我们这里就先跳过吧~</p><h3 id="Exercise-5-熟悉ELF"><a href="#Exercise-5-熟悉ELF" class="headerlink" title="Exercise 5 - 熟悉ELF"></a>Exercise 5 - 熟悉ELF</h3><p>关于ELF的头部结构刚刚已经进行过了一定的分析。除了刚刚研究过的程序段（segment）之外，ELF实际上还有另一种划分，称为节（section，其实有的时候也翻译成段，为了避免误解，接下来用英文来表达这两个概念好了）。section同样也有一个像proghdr表一样的secthdr表。它位于整个文件的最后（而不是proghdr表的后面）。</p><p>ELF文件中起主要作用的就是.text, .data和.rodata这三个section。其中，.data段用于存放有初值的变量，而.rodata段用于存放一些诸如字符串字面量的东西。此外，还有我们熟悉的.bss段，只不过.bss段在装载时全部被置为0，因而在ELF中不需要实际保存这些0，只需要保存相应的地址就可以了。</p><p>简单来说，程序的链接是以section为单位的，而程序的装载是以segment为单位的（正如我们在boot loader中所看到的）。也正是因为如此，程序装载后，secthdr表不一定会被装载到内存中（这可能取决于初次装入内存的大小是否覆盖到了这一区域，如果没有，是不需要特意将这一部分装进来的，因为执行过程中用不到）。</p><p>值得注意的是，在secthdr中，对于每个section，有两个地址值，分别称为VMA和LMA，即虚拟地址（又称链接地址）和装载地址。顾名思义，LMA也就是装载进内存时的目标地址，而VMA也就是执行的地址。听上去很奇怪，为什么装载的地址和执行的地址会是两个地址呢？执行的地址到底是啥意思？</p><p>实际上，这里的执行地址的意思是，当需要根据这个section来寻址的时候（比如绝对跳转、数据访问等），所使用的地址的计算标准。这也就是链接地址这个名字的由来，毕竟，程序中地址的重定位是在链接阶段完成的。所以说，链接地址是提供给链接器做重定位用的，而装载地址是提供给装载器为程序挑选内存位置用的。两个地址虽然通常情况下应当保持一致（不然链接器重定位出来的地址不就错了吗= =），但他们的确是两个东西，而且在特殊的情况下是可以不一样的。</p><p>boot loader程序的链接地址是可以在<code>boot/Makefrag</code>中修改的。练习5希望我们修改链接地址并分析会在哪条指令开始出错。简单分析一下，对于PC相对寻址的代码是肯定不会收到链接地址的影响的，只有出现绝对寻址时，才会因为链接地址的篡改而出错。我们顺着<code>boot.S</code>的代码看下去，第一条出现绝对寻址的指令就是从实模式切换到保护模式的ljmp指令（第55行）。这一行将会在链接时被链接器重定位到我们所指定的链接地址处相应的位置，与装载地址产生差别，从而导致其跳转到错误的地方。</p><p>理论分析如此，接下来是实验验证：</p><p>将<code>boot/Makefrag</code>中的<code>-Ttext 0x7c00</code>修改为<code>-Ttext 0x7d00</code>，这样一来，链接地址就变成了0x7d00。事实上，<code>boot.out</code>中的装载地址也被设置成了0x7d00。然而，在BIOS装载boot loader时，仍然会将其装载到0x7c00：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5i 0x7c00</span><br><span class="line">=&gt; 0x7c00:cli    </span><br><span class="line">   0x7c01:cld    </span><br><span class="line">   0x7c02:xor    %ax,%ax</span><br><span class="line">   0x7c04:mov    %ax,%ds</span><br><span class="line">   0x7c06:mov    %ax,%es</span><br></pre></td></tr></table></figure><p>接下来我们执行到刚刚分析到会出错的指令处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c2d] =&gt; 0x7c2d:ljmp   $0x8,$0x7d32</span><br></pre></td></tr></table></figure><p>可以看到，这条语句原本的跳转目标是0x7c32，现在已经变成了0x7d32，但装载地址并没有变。继续运行这句指令，将会引发错误。在执行了<code>make qemu-gdb</code>的窗口中，会出现这些信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EAX=00000011 EBX=00000000 ECX=00000000 EDX=00000080</span><br><span class="line">ESI=00000000 EDI=00000000 EBP=00000000 ESP=00006f20</span><br><span class="line">EIP=00007c2d EFL=00000006 [-----P-] CPL=0 II=0 A20=1 SMM=0 HLT=0</span><br><span class="line">ES =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]</span><br><span class="line">CS =0000 00000000 0000ffff 00009b00 DPL=0 CS16 [-RA]</span><br><span class="line">SS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]</span><br><span class="line">DS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]</span><br><span class="line">FS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]</span><br><span class="line">GS =0000 00000000 0000ffff 00009300 DPL=0 DS16 [-WA]</span><br><span class="line">LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT</span><br><span class="line">TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy</span><br><span class="line">GDT=     000cc483 0000ffff</span><br><span class="line">IDT=     00000000 000003ff</span><br><span class="line">CR0=00000011 CR2=00000000 CR3=00000000 CR4=00000000</span><br><span class="line">DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000 </span><br><span class="line">DR6=ffff0ff0 DR7=00000400</span><br><span class="line">EFER=0000000000000000</span><br><span class="line">Triple fault.  Halting for inspection via QEMU monitor.</span><br></pre></td></tr></table></figure><p>记得将链接地址改回来再往下做！</p><h3 id="Exercise-6-内核的装载"><a href="#Exercise-6-内核的装载" class="headerlink" title="Exercise 6 - 内核的装载"></a>Exercise 6 - 内核的装载</h3><p>练习6的内容是，在BIOS进入boot loader的时刻和boot loader进入系统内核的时刻，分别查看0x00100000处的内容，并解释他们为什么不一样，以及进入内核时这里放的是啥。</p><p>首先在0x7c00处设置断点，并查看相应内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x100010:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>我们之前已经分析过，跳转到内核的代码位于0x7d6b处，因此我们直接将断点设置在0x7d6b，执行continue命令，并再次查看内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br></pre></td></tr></table></figure><p>可以看到，确实发生了变化。事实上，我们之前已经看到，0x00100000正是kernel的最小的链接地址，它对应于.text段。也就是说，此处0x00100000已经被填充上了kernel文件的.text段的内容。</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>在Part 2中我们执行<code>objdump -h obj/kern/kernel</code>时发现，kernel的VMA和LMA并不相同。LMA从1MB开始（0x00100000），而VMA从0xf0100000开始。</p><p>操作系统内核通常都喜欢被链接到很高的地址，从而将下方的地址空间全部留给用户程序使用。</p><p>那么，VMA在0xf0100000而LMA在0x00100000，它到底为什么能正常执行呢？更严重的问题是，假如这台计算机内存只有2G，根本就没有0xf0100000这个地址，那又该怎么办呢？事实上，处理器会带有一个内存管理硬件负责将虚拟地址0xf0100000映射到物理地址0x00100000。</p><p>接下来我们要做的事情就是完成前4MB的物理内存的映射工作。</p><p>在<code>kern/entry.S</code>中将CR0_PG置位之前，内存访问操作全部都是直接访问物理地址。置位后，所有内存地址会被作为虚拟地址，经过映射后再进行访问。</p><h3 id="Exercise-7-虚拟内存的开启"><a href="#Exercise-7-虚拟内存的开启" class="headerlink" title="Exercise 7 - 虚拟内存的开启"></a>Exercise 7 - 虚拟内存的开启</h3><p>练习7要求我们在置位CR0_PG的地方（<code>movl %eax, %cr0</code>）设置断点，观察这条指令执行前后，地址0x00100000和0xf0100000处的值，并理解这一现象。在这之后，将这条语句注释，并分析会率先在哪条指令处出错。</p><p>我们首先打开<code>obj/kern/kernel.asm</code>文件，找到如下两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl%eax, %cr0</span><br><span class="line">f0100025:0f 22 c0             mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>这里就是我们要找的那条指令啦。我们运行程序，在此处设置断点。要注意的是，此时并没有开启虚拟内存，所以此处的地址应当是实际装载到内存中的地址0x00100025。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x00100025</span><br><span class="line">Breakpoint 3 at 0x100025</span><br><span class="line">(gdb) cont</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x100025:mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>顺利将程序断在了此处。</p><p>观察此时0x00100000和0xf0100000分别对应的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;:0x000000000x000000000x000000000x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>可以看到，访问0x00100000时，可以看到实际的程序数据，而0xf0100000处则是空的。我们执行完这条指令后再次查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0x100010:0x340000040x2000b8120x220f00110xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;:0x1badb0020x000000000xe4524ffe0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:0x340000040x2000b8120x220f00110xc0200fd8</span><br></pre></td></tr></table></figure><p>哇塞，很神奇是不是。0xf0100000同样也被映射到了0x00100000处，访问0xf0100000和访问0x00100000得到的是同样的数据。这说明刚刚的指令确实顺利打开了虚拟内存的开关。至于这个映射关系，实际上是6.828提供的这个基础框架中原本所编写的。</p><p>至于第二个问题：如果注释掉这条置位指令，会在哪里执行出错。我们需要先打印后面的若干条指令来进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100028:mov    $0xf010002f,%eax</span><br><span class="line">   0x10002d:jmp    *%eax</span><br><span class="line">   0x10002f:mov    $0x0,%ebp</span><br><span class="line">   0x100034:mov    $0xf0110000,%esp</span><br><span class="line">   0x100039:call   0x1000a6</span><br><span class="line">   0x10003e:jmp    0x10003e</span><br><span class="line">   0x100040:push   %ebp</span><br><span class="line">   0x100041:mov    %esp,%ebp</span><br><span class="line">   0x100043:push   %esi</span><br><span class="line">   0x100044:push   %ebx</span><br></pre></td></tr></table></figure><p>可以看到，接下来一条指令将0xf010002f（在注释掉刚刚那条指令后，这个地址显然会前移的嗷，所以一会实验中出现的这个地址肯定不是0xf010002f）中的值赋给%eax。显然，假如不开启虚拟地址，这条指令的表现就已经与预期不符了。但这仅仅是一条赋值语句，并不会引发错误。我们继续往下看。下一条指令希望跳转到%eax处，也就是物理地址的0xf010002f。此时%eax所指的物理地址0xf010002f显然超出了可以访问的上限（因为6.828中用到的这套东西的内存总共只有256MB），因此，执行下一条指令时，将会在取指阶段由于访问错误内存地址而出错。我们来验证一下ho。</p><p>首先注释掉<code>kern/entry.S</code>第62行的指令，然后重新编译。执行到0x10002a处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x10002a:jmp    *%eax</span><br></pre></td></tr></table></figure><p>继续执行，发现PC指针指向了%eax中的0xf010002c，也就是注释掉那条语句之前的0xf010002f。总之，就是一个越界的地址。继续执行，就崩了。错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</span><br></pre></td></tr></table></figure><p>这与我们的分析是一致的。（好吧，其实是跑出来这个结果之后才得到的刚刚这串分析- -本来以为在跳转的时候就会死掉）</p><h3 id="Exercise-8-print"><a href="#Exercise-8-print" class="headerlink" title="Exercise 8 - print"></a>Exercise 8 - print</h3><p>在<code>kern/printf.c</code>, <code>lib/printfmt.c</code>, <code>kern/console.c</code>中有打印相关的代码。练习8要求我们补全其中的八进制数字显示的部分。我们首先来研究一下这几个文件之间的组织关系。</p><p>我们观察<code>printf.c</code>，从<code>cprintf()</code>函数开始看起。这个函数调用了vcprintf()，而vcprintf()调用了<code>printfmt.c</code>中的vprintfmt()函数，并将putch()函数指针作为参数传递了进去。结合我们之前对glibc中printf的实现的认识，vprintfmt()函数是一个通用的写函数，不仅可以打印到标准输出，也可以写到文件、socket等其他地方。</p><p>接下来具体来看vprintfmt()函数。在循环体的开始，首先依次向后处理字符，直接打印，遇到’\0’则结束，直到遇到’%’。接下来就是处理%后面可以跟的各种字符。对于超过1个字符的修饰符，会goto reswitch继续读取下一个字符。我们很容易可以找到<code>case &#39;o&#39;</code>，这里就是我们需要添加功能的地方。我们只需要模仿%d, %u等分支的行为，修改代码即可。</p><p>修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">    num = getuint(&amp;ap, lflag);</span><br><span class="line">    base = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>我们在<code>monitor.c</code>中添加一条cprintf调用来测试打印的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;Test printing octal: %o\n&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>重新编译并运行，实际打印出来的效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">Test printing octal: 173</span><br></pre></td></tr></table></figure><p>173即十进制123的八进制值。因此，这个功能就顺利实现完啦~</p><p>回答一下下面提出的几个问题：</p><blockquote><p>Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p></blockquote><p>很容易看到，接口是<code>printf.c</code>中putch()函数里调用的cputchar(ch)。putch()通过调用<code>console.c</code>中封装好的打印字符功能，从而越过底层接口直接实现打印功能。</p><blockquote><p>Explain the following from <code>console.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这段代码位于<code>console.c</code>的195~202行。所处的函数的功能是根据要打印的字符来执行打印动作。这段代码的上方已经将各种类型的字符都处理完毕了，包括退格、换行、回车等。CRT_SIZE是一个宏，扩展到<code>(CRT_COLS*CRT_ROWS)</code>。CRT即阴极射线管。CRT_COLS和CRT_ROWS即屏幕上可以显示的列数和行数。因而这段代码的功能就是当当前的光标位置已经超出所能显示的上限时，就将最上面一行移除，并将剩下的部分整体上移一行。</p><blockquote><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure><ul><li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li><li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li></ul></blockquote><p>进入到这条cprintf()调用，可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf0100a5b</span> &lt;cprintf&gt;:push   %ebp</span><br><span class="line"><span class="number">0xf0100a5c</span> &lt;cprintf+<span class="number">1</span>&gt;:mov    %esp,%ebp</span><br><span class="line"><span class="number">0xf0100a5e</span> &lt;cprintf+<span class="number">3</span>&gt;:sub    $<span class="number">0x10</span>,%esp</span><br><span class="line"><span class="number">0xf0100a61</span> &lt;cprintf+<span class="number">6</span>&gt;:lea    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line"><span class="number">0xf0100a64</span> &lt;cprintf+<span class="number">9</span>&gt;:push   %eax</span><br><span class="line"><span class="number">0xf0100a65</span> &lt;cprintf+<span class="number">10</span>&gt;:pushl  <span class="number">0x8</span>(%ebp)</span><br><span class="line"><span class="number">0xf0100a68</span> &lt;cprintf+<span class="number">13</span>&gt;:call   <span class="number">0xf0100a24</span> &lt;vcprintf&gt;</span><br></pre></td></tr></table></figure><p>根据倒序进栈的规则，第二次push的即为第一个参数fmt，指向的是格式串，应当位于.rodata区。通过info reg和x/x命令可以查看到fmt指向的地址为0xf0101d4e，而通过objdump可以看到.rodata区的起始地址为0xf0101a40，长度为6d0，因此0xf0101d4e确实位于.rodata区内。</p><p>而ap则是先进栈的参数，通过查看%eax即可得到ap的值为0xf010ff54。这显然是一个创建在栈上的结构体，因此这个地址的获取是通过%ebp偏移得到的。</p><p>后面这个问题太无聊了，就先跳过了奥…</p><blockquote><p>Run the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure><p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. </p><p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p></blockquote><p>这个其实没什么必要跑了，算一算57616的十六进制，输出应该是He110 World（一看这个输出就知道没算错…）。首先%x被处理成十六进制数显示，$57616<em>{10}=e110</em>{16}$，然后&amp;i被作为一个字符指针，根据小端规则，i在内存中的存放为72 6c 64 00，也就是”rld\0”。于是结果就很清楚了。</p><p>那么，如果x86是大端规则，i显然应该变成0x726c6400，而57616是不用变的。</p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></blockquote><p>首先，在调用这个函数之前，数字3和fmt串的地址依次进栈。在解析可变参数列表时，是从fmt的下一个参数，也就是3，开始往栈底的方向读取。因此，y=%d处的%d读取的应当是开始压参数之前的栈顶元素。</p><blockquote><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p></blockquote><p>题目大意是，假如gcc不再是参数倒序进栈，而是顺序进栈，那么该如何传递这个可变参数呢？</p><p>如果改为顺序进栈，主要的障碍在于，可变参数会成为最后进栈的内容，因而被调用方无法知道如何通过%ebp的偏移得到非可变部分的参数。因此，自然就没办法实现这个可变参数的功能了。</p><p>不过题目是问如何从cprintf这个函数出发去满足这个需求，那我觉得让最后一个可变参数是一个表示可变参数数量的数字是可行的，当然这个办法对使用者很不友好，因为他每次打完可变参数都需要数一下个数写上去。如果编译器允许的话，把可变参数和fmt的顺序对调也是不错的选择（但是多半是不允许的奥）。</p><h3 id="Exercise-9-栈的初始化"><a href="#Exercise-9-栈的初始化" class="headerlink" title="Exercise 9 - 栈的初始化"></a>Exercise 9 - 栈的初始化</h3><p>练习9让我们判断一下内核是在何时初始化了它的栈，以及栈在内存的什么位置。</p><p>在<code>kern/entry.S</code>文件的77行有这样一条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl$(bootstacktop),%esp</span><br></pre></td></tr></table></figure><p>显然，这就是初始化栈的地方。初始化的位置是靠bootstacktop标签来定位的。这个标签位于.data段，在.text段的下方，之间有一个<code>.space KSTKSIZE</code>的间隔。这就是内核为栈预留的空间。至于这个KSTKSIZE，可以在<code>inc/memlayout.h</code>里找到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTKSIZE(8*PGSIZE)</span></span><br></pre></td></tr></table></figure><p>可以看到，为内核栈预留了8页的大小。栈指针esp被初始化到了这段空间的底端（高地址端）。</p><h3 id="Exercise-10-函数调用与栈"><a href="#Exercise-10-函数调用与栈" class="headerlink" title="Exercise 10 - 函数调用与栈"></a>Exercise 10 - 函数调用与栈</h3><p>在<code>kern/init.c</code>中定义了一个test_backtrace()函数。它是一个递归函数。练习10要求我们跟踪一下这个函数，分析一下每次递归的过程总共push了多少东西到栈里，分别是啥。</p><p>首先在test_backtrace()上设个断点，然后直接跑到这里。我们既然要观察push的问题，那我们自然需要随时关注%esp。我们可以使用<code>display $esp</code>命令，使得每次执行一条指令后都会打印出当前的%esp值。</p><p>这个函数的源代码非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">test_backtrace</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cprintf(<span class="string">&quot;entering test_backtrace %d\n&quot;</span>, x);</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">test_backtrace(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cprintf(<span class="string">&quot;leaving test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，在反汇编出来的代码中，我们看到了一条奇怪的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f0100045: call   f01001bc &lt;__x86.get_pc_thunk.bx&gt;</span><br></pre></td></tr></table></figure><p>这个函数是干啥的呢？看着怪吓人的。不过吧，稍微跟进去看一眼，发现只有两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    (%esp),%ebx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>不是很懂这为什么要做成一个函数调用..</p><p>我们忽略这个函数调用吧。反正，它没有干扰我们的栈就是了。</p><p>简单分析一下代码就可以知道，每次递归调用之前push了8个单元（也就是32个字节）进栈。分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f0100040:  push %ebp</span><br><span class="line">f0100043:  push %esi</span><br><span class="line">f0100044:  push %ebx</span><br><span class="line">f0100095:  sub  $0xc, %esp</span><br><span class="line">f010009b:  push %eax</span><br><span class="line">f010009c:  call f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure><p>其中，第1, 2, 3, 5条就是直接的push指令，前三条分别将%ebp, %esi, %ebx保存到了栈中，而第五条则是向内层传递参数x。</p><p>至于第四条的sub语句，查阅了一下资料，是为了使得离开函数后可以统一使用<code>add $0x10, %esp</code>来弹出参数。因为原本只有一个参数，所以自然要补上3个空穴来达到0x10也就是16个字节。</p><p>此外call指令本身也会将返回地址压入栈中。这样一来，递归过程中栈内的情况就清楚了。</p><h3 id="Exercise-11-实现backtrace"><a href="#Exercise-11-实现backtrace" class="headerlink" title="Exercise 11 - 实现backtrace"></a>Exercise 11 - 实现backtrace</h3><p>终于真正开始写代码了。练习11的内容是实现一个backtrace的函数，这个函数会将到目前为止的函数调用栈的信息打印出来，信息包括ebp，返回地址，五个参数的值。</p><p>有几个关键点：</p><ul><li><p>当前ebp的取得。所幸，6.828给我们提供了read_ebp()函数，所以我们不需要内联汇编来自己实现了。（不过其实就算没有提供，也就是一行汇编的事情）</p></li><li><p>ebp链。如何定位到上一层函数的调用栈呢？根据gcc对于函数调用的约定，调用函数后，会首先执行<code>push %ebp</code>和<code>mov %esp, %ebp</code>的操作，因此%ebp指向的内存单元的值，即为old_ebp。</p></li><li><p>何时结束。实验文档提示我们去<code>kern/entry.S</code>中找答案。在文件的71行，有如下的代码（和注释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl$0x0,%ebp# nuke frame pointer</span><br></pre></td></tr></table></figure><p>这就很清楚了，初始的时候%ebp被置为0，所以最外层的函数栈中保存的old_ebp即为0。所以当我们的%ebp读取到的值为0时，就代表回溯过程已经结束了。</p></li><li><p>返回地址和参数的位置。熟悉gcc函数调用规则就会清楚，返回地址和前5个参数依次位于old_ebp下方（高地址方向）的连续六个内存单元中。</p></li></ul><p>解决了这四个关键问题，代码的编写就很容易了。参考代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> cur_ebp = read_ebp();</span><br><span class="line"><span class="keyword">uint32_t</span> ret_eip;</span><br><span class="line"><span class="keyword">uint32_t</span> arg;</span><br><span class="line">cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (cur_ebp)</span><br><span class="line">&#123;</span><br><span class="line">ret_eip = *((<span class="keyword">uint32_t</span> *)(cur_ebp) + <span class="number">1</span>);</span><br><span class="line">cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args&quot;</span>, cur_ebp, ret_eip);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arg = *((<span class="keyword">uint32_t</span> *)(cur_ebp) + <span class="number">2</span> + i);</span><br><span class="line">cprintf(<span class="string">&quot; %08x&quot;</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">cur_ebp = *(<span class="keyword">uint32_t</span> *)(cur_ebp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还要求我们将这个函数添加到命令中，使得可以通过命令来执行。这个非常容易，在commands里加一条就可以了。</p><h3 id="Exercise-12-搜索符号表"><a href="#Exercise-12-搜索符号表" class="headerlink" title="Exercise 12 - 搜索符号表"></a>Exercise 12 - 搜索符号表</h3><p>练习11中输出的backtrace信息是非常原始的，只包含了ebp和eip指向的地址，但并不能直观地看到对应的文件和函数。练习12即要求我们在backtrace信息中添加函数名、文件名、行号等信息。</p><p>看上去非常困难，但是其实代码框架里已经给我们提供了大部分的内容。在<code>kdebug.c</code>文件中定义了debuginfo_eip()函数，可以从符号表中读取出参数addr对应的各种信息，除了行号的读取留给我们自己去实现。</p><p>符号表的一些基本定义位于<code>inc/stab.h</code>中，其中定义了各种不同符号表项的类型，以及符号表项的结构体struct Stab。因此，内存中的整张符号表，就可以解析成struct Stab的数组。</p><p>值得注意的是，这里的符号表和我写的破烂编译器用的符号表可以说是完全不同的两种东西了..这里的符号表包含了各种有名字的和没有名字的信息，甚至包含了源文件中的每个有效的行号与内存偏移地址的映射关系。符号表具体内容可以用以下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -G obj/kern/kernel</span><br></pre></td></tr></table></figure><p>强烈建议在开始做这个练习之前，先对照着源文件和obj文件阅读一下符号表，读完之后，基本上就明白需要做些什么了。</p><p>符号表中，为了提高搜索的效率，同一文件或同一函数中的符号的地址是递增排列的，因此对于一个特定的地址，可以通过二分查找的方式在符号表中搜索，而不必线性遍历。当然，这个二分搜索的过程已经在框架中实现好了。我们要做的，就是合理地调用这个函数来读取行号。</p><p>这里给出我的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &gt; rline)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><p>最后补充一下之前mon_backtrace()函数中的内容，将第二行输出添加进去。扩充后的mon_backtrace()函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> cur_ebp = read_ebp();</span><br><span class="line"><span class="keyword">uint32_t</span> ret_eip;</span><br><span class="line"><span class="keyword">uint32_t</span> arg;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (cur_ebp)</span><br><span class="line">&#123;</span><br><span class="line">ret_eip = *((<span class="keyword">uint32_t</span> *)(cur_ebp) + <span class="number">1</span>);</span><br><span class="line">cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args&quot;</span>, cur_ebp, ret_eip);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arg = *((<span class="keyword">uint32_t</span> *)(cur_ebp) + <span class="number">2</span> + i);</span><br><span class="line">cprintf(<span class="string">&quot; %08x&quot;</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">debuginfo_eip(ret_eip, &amp;info);</span><br><span class="line">cprintf(<span class="string">&quot;       %s:%d: %.*s+%x\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ret_eip - info.eip_fn_addr);</span><br><span class="line">cur_ebp = *(<span class="keyword">uint32_t</span> *)(cur_ebp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下<code>make grade</code>，终于满分通过了。实验一结束~</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实验1其实内容还是挺多的，但是难度总体来说倒也不是很大，主要是带我们了解了一下计算机从启动到稳定地运行起操作系统内核所经历的事情，以及函数调用过程中栈的管理，并通过backtrace程序的编写，更好地理解了ebp的传递链，以及栈中的组织结构。用到了一些专业课里学过的各种小知识点，不光是操作系统这一门，也算是一个巩固吧。总体来说还是花了一些时间的。那么就继续实验2吧~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天决定开始刷MIT6.828的实验。算是弥补一下鄙校操作系统课程实验非常落后而愚蠢的缺憾吧。这篇笔记的内容呢，主要是我在实验过程中的一些主要思路和关键点的记录，所以可能并不能作为一篇详尽的实验指导性质的文字，因为很多操作上的、工具使用上的小细节我是没有一一列出的。假如你是自己独立地在钻研这个实验，对工具有一定的熟悉程度，经过重复的研究和思考之后，卡在某些地方，在本文中找到一些小的启发倒是有可能的。当然，很多内容也是我结合曾经课上课下所学的各种知识所做的一些个人分析，错误也是肯定会有的。好了，话不多说，直接开始。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一个简单编译器的实现</title>
    <link href="http://example.com/2021/06/21/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/06/21/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-06-21T08:53:33.000Z</published>
    <updated>2021-06-21T09:01:37.410Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----------">一个简单编译器的实现</a><ul><li><a href="#tranlang--">TranLang介绍</a></li><li><a href="#-----">词法分析器</a></li><li><a href="#-----">语法分析器</a></li><li><a href="#-------">语法树和符号表</a></li><li><a href="#------">中间代码生成</a></li><li><a href="#------">汇编代码生成</a></li></ul></li></ul><!-- tocstop --><p>上个月编写了一个简单的的编译器，语言是自己定义的一门类C的语言，名曰TranLang。在这里，简单介绍一下TranLang的基本情况以及开发过程中的一些体会和心得。</p><span id="more"></span><h1 id="一个简单编译器的实现"><a href="#一个简单编译器的实现" class="headerlink" title="一个简单编译器的实现"></a>一个简单编译器的实现</h1><h2 id="TranLang介绍"><a href="#TranLang介绍" class="headerlink" title="TranLang介绍"></a>TranLang介绍</h2><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><h2 id="语法树和符号表"><a href="#语法树和符号表" class="headerlink" title="语法树和符号表"></a>语法树和符号表</h2><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><h2 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a>汇编代码生成</h2>]]></content>
    
    
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#----------&quot;&gt;一个简单编译器的实现&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#tranlang--&quot;&gt;TranLang介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#-----&quot;&gt;词法分析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#-----&quot;&gt;语法分析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#-------&quot;&gt;语法树和符号表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#------&quot;&gt;中间代码生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#------&quot;&gt;汇编代码生成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;上个月编写了一个简单的的编译器，语言是自己定义的一门类C的语言，名曰TranLang。在这里，简单介绍一下TranLang的基本情况以及开发过程中的一些体会和心得。&lt;/p&gt;</summary>
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://example.com/2021/06/09/Test/"/>
    <id>http://example.com/2021/06/09/Test/</id>
    <published>2021-06-09T15:27:48.000Z</published>
    <updated>2021-06-21T06:43:12.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HHHHHHHHHHHHHHHHHH"><a href="#HHHHHHHHHHHHHHHHHH" class="headerlink" title="HHHHHHHHHHHHHHHHHH"></a>HHHHHHHHHHHHHHHHHH</h1><p>123</p><!-- toc --><ul><li><a href="#asada">asada</a><ul><li><a href="#dasf">dasf</a><ul><li><a href="#asfsdg">asfsdg</a></li></ul></li></ul></li><li><a href="#asdfs">asdfs</a></li></ul><!-- tocstop --><p>[toc]</p><p>hhhhhhhhh!! hhh</p><span id="more"></span><p>[toc]</p><p>哈哈哈哈哈哈哈$aaabbccc$哈哈哈哈哈哈哈哈哈哈</p><script type="math/tex; mode=display">aaa+bbb</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>aaaaaaaaaaaaa</p></blockquote><h2 id="asada"><a href="#asada" class="headerlink" title="asada"></a>asada</h2><h3 id="dasf"><a href="#dasf" class="headerlink" title="dasf"></a>dasf</h3><h4 id="asfsdg"><a href="#asfsdg" class="headerlink" title="asfsdg"></a>asfsdg</h4><h2 id="asdfs"><a href="#asdfs" class="headerlink" title="asdfs"></a>asdfs</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=479938888&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HHHHHHHHHHHHHHHHHH&quot;&gt;&lt;a href=&quot;#HHHHHHHHHHHHHHHHHH&quot; class=&quot;headerlink&quot; title=&quot;HHHHHHHHHHHHHHHHHH&quot;&gt;&lt;/a&gt;HHHHHHHHHHHHHHHHHH&lt;/h1&gt;&lt;p&gt;123&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#asada&quot;&gt;asada&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#dasf&quot;&gt;dasf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#asfsdg&quot;&gt;asfsdg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#asdfs&quot;&gt;asdfs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;hhhhhhhhh!! hhh&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/06/09/hello-world/"/>
    <id>http://example.com/2021/06/09/hello-world/</id>
    <published>2021-06-09T15:02:45.241Z</published>
    <updated>2021-06-09T15:02:45.241Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
